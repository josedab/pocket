/**
 * @pocket/codegen - Form Component Generator
 *
 * Generates React form components from Pocket collection schemas.
 * Produces controlled form components with validation, default values,
 * and submit handlers.
 *
 * @module @pocket/codegen
 */

import type { CollectionSchema, GeneratedFile, SchemaField } from '../types.js';

function toPascalCase(name: string): string {
  return name
    .split(/[-_\s]+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
    .replace(/s$/, '');
}

function fieldToInputType(field: SchemaField): string {
  switch (field.type) {
    case 'string':
      if (field.validation?.pattern) return 'text';
      if (field.validation?.enum) return 'select';
      return 'text';
    case 'number':
      return 'number';
    case 'boolean':
      return 'checkbox';
    case 'date':
      return 'date';
    default:
      return 'text';
  }
}

function fieldToDefaultValue(field: SchemaField): string {
  if (field.default !== undefined) return JSON.stringify(field.default);
  switch (field.type) {
    case 'string':
      return "''";
    case 'number':
      return '0';
    case 'boolean':
      return 'false';
    case 'date':
      return "''";
    default:
      return "''";
  }
}

/**
 * FormGenerator produces React form components from collection schemas.
 */
export class FormGenerator {
  /**
   * Generate form component files for all collections.
   */
  generateForms(collections: CollectionSchema[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    const exportEntries: string[] = [];

    for (const collection of collections) {
      const singular = toPascalCase(collection.name);
      const content = this.generateFormFile(collection, singular);
      files.push({
        path: `forms/${collection.name}-form.tsx`,
        content,
        type: 'crud',
      });
      exportEntries.push(
        `export { ${singular}Form } from './${collection.name}-form.js';`,
      );
    }

    // Index file
    files.push({
      path: 'forms/index.ts',
      content: [
        '/**',
        ' * Auto-generated form components',
        ' * DO NOT EDIT - Generated by @pocket/codegen',
        ' */',
        '',
        ...exportEntries,
        '',
      ].join('\n'),
      type: 'index',
    });

    return files;
  }

  private generateFormFile(collection: CollectionSchema, singular: string): string {
    const editableFields = Object.entries(collection.fields).filter(
      ([name]) => name !== '_id' && name !== '_rev',
    );

    const stateLines = editableFields
      .map(([name, field]) => `    ${name}: ${fieldToDefaultValue(field)},`)
      .join('\n');

    const inputElements = editableFields
      .map(([name, field]) => this.generateInputElement(name, field))
      .join('\n\n');

    return `/**
 * Auto-generated form for "${collection.name}" collection
 * DO NOT EDIT - Generated by @pocket/codegen
 */

import React, { useState, useCallback } from 'react';

export interface ${singular}FormProps {
  /** Initial values for editing existing documents */
  initialValues?: Partial<Record<string, unknown>>;
  /** Called on successful form submission */
  onSubmit: (values: Record<string, unknown>) => void | Promise<void>;
  /** Optional cancel handler */
  onCancel?: () => void;
  /** Submit button text */
  submitLabel?: string;
  /** Whether the form is in a loading state */
  loading?: boolean;
}

export function ${singular}Form({
  initialValues,
  onSubmit,
  onCancel,
  submitLabel = 'Save',
  loading = false,
}: ${singular}FormProps) {
  const [values, setValues] = useState<Record<string, unknown>>({
${stateLines}
    ...initialValues,
  });
  const [errors, setErrors] = useState<Record<string, string>>({});

  const handleChange = useCallback((field: string, value: unknown) => {
    setValues((prev) => ({ ...prev, [field]: value }));
    setErrors((prev) => {
      const next = { ...prev };
      delete next[field];
      return next;
    });
  }, []);

  const validate = useCallback((): boolean => {
    const newErrors: Record<string, string> = {};
${this.generateValidation(editableFields)}
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [values]);

  const handleSubmit = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      if (!validate()) return;
      await onSubmit(values);
    },
    [values, validate, onSubmit],
  );

  return (
    <form onSubmit={handleSubmit}>
${inputElements}

      <div style={{ display: 'flex', gap: '8px', marginTop: '16px' }}>
        <button type="submit" disabled={loading}>
          {loading ? 'Saving...' : submitLabel}
        </button>
        {onCancel && (
          <button type="button" onClick={onCancel} disabled={loading}>
            Cancel
          </button>
        )}
      </div>
    </form>
  );
}
`;
  }

  private generateInputElement(name: string, field: SchemaField): string {
    const inputType = fieldToInputType(field);
    const label = name.charAt(0).toUpperCase() + name.slice(1).replace(/([A-Z])/g, ' $1');

    if (inputType === 'select' && field.validation?.enum) {
      const options = field.validation.enum
        .map((v) => `          <option key={${JSON.stringify(v)}} value={${JSON.stringify(v)}}>${v}</option>`)
        .join('\n');
      return `      <div style={{ marginBottom: '12px' }}>
        <label htmlFor="${name}">${label}</label>
        <select
          id="${name}"
          value={String(values.${name} ?? '')}
          onChange={(e) => handleChange('${name}', e.target.value)}
        >
          <option value="">Select...</option>
${options}
        </select>
        {errors.${name} && <span style={{ color: 'red' }}>{errors.${name}}</span>}
      </div>`;
    }

    if (inputType === 'checkbox') {
      return `      <div style={{ marginBottom: '12px' }}>
        <label>
          <input
            type="checkbox"
            checked={Boolean(values.${name})}
            onChange={(e) => handleChange('${name}', e.target.checked)}
          />
          {' '}${label}
        </label>
      </div>`;
    }

    return `      <div style={{ marginBottom: '12px' }}>
        <label htmlFor="${name}">${label}</label>
        <input
          id="${name}"
          type="${inputType}"
          value={String(values.${name} ?? '')}
          onChange={(e) => handleChange('${name}', ${inputType === 'number' ? 'Number(e.target.value)' : 'e.target.value'})}
          ${field.validation?.min !== undefined ? `min={${field.validation.min}}` : ''}
          ${field.validation?.max !== undefined ? `max={${field.validation.max}}` : ''}
        />
        {errors.${name} && <span style={{ color: 'red' }}>{errors.${name}}</span>}
      </div>`;
  }

  private generateValidation(fields: [string, SchemaField][]): string {
    const lines: string[] = [];
    for (const [name, field] of fields) {
      if (field.required) {
        lines.push(
          `    if (values.${name} === undefined || values.${name} === '' || values.${name} === null) {`,
          `      newErrors.${name} = '${name} is required';`,
          `    }`,
        );
      }
      if (field.validation?.min !== undefined && field.type === 'number') {
        lines.push(
          `    if (typeof values.${name} === 'number' && values.${name} < ${field.validation.min}) {`,
          `      newErrors.${name} = '${name} must be at least ${field.validation.min}';`,
          `    }`,
        );
      }
      if (field.validation?.max !== undefined && field.type === 'number') {
        lines.push(
          `    if (typeof values.${name} === 'number' && values.${name} > ${field.validation.max}) {`,
          `      newErrors.${name} = '${name} must be at most ${field.validation.max}';`,
          `    }`,
        );
      }
    }
    return lines.join('\n');
  }
}

/**
 * Create a FormGenerator instance.
 */
export function createFormGenerator(): FormGenerator {
  return new FormGenerator();
}
