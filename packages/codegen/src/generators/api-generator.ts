/**
 * @pocket/codegen - REST API Stub Generator
 *
 * Generates Express-compatible REST API route handlers from
 * Pocket collection schemas. Includes request validation,
 * error handling, and typed request/response interfaces.
 *
 * @module @pocket/codegen
 */

import type { CollectionSchema, GeneratedFile } from '../types.js';

function toPascalCase(name: string): string {
  return name
    .split(/[-_\s]+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
    .replace(/s$/, '');
}

/**
 * APIGenerator produces REST API route handlers from schemas.
 */
export class APIGenerator {
  /**
   * Generate API route files for all collections.
   */
  generateAPI(collections: CollectionSchema[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    const routeImports: string[] = [];

    for (const collection of collections) {
      const content = this.generateRouteFile(collection);
      files.push({
        path: `api/${collection.name}.routes.ts`,
        content,
        type: 'crud',
      });
      routeImports.push(collection.name);
    }

    // Router index file
    files.push({
      path: 'api/index.ts',
      content: this.generateRouterIndex(routeImports),
      type: 'index',
    });

    return files;
  }

  private generateRouteFile(collection: CollectionSchema): string {
    const singular = toPascalCase(collection.name);

    return `/**
 * Auto-generated REST API routes for "${collection.name}"
 * DO NOT EDIT - Generated by @pocket/codegen
 */

import type { Database } from '@pocket/core';

export interface APIRequest {
  params: Record<string, string>;
  query: Record<string, string>;
  body: unknown;
}

export interface APIResponse {
  status: (code: number) => APIResponse;
  json: (data: unknown) => void;
}

/**
 * Create route handlers for the ${collection.name} collection.
 */
export function create${singular}Routes(db: Database) {
  const collection = db.collection('${collection.name}');

  return {
    /**
     * GET /${collection.name}
     * List all documents with optional filtering and pagination.
     */
    async list(req: APIRequest, res: APIResponse): Promise<void> {
      try {
        const limit = req.query.limit ? parseInt(req.query.limit, 10) : 50;
        const skip = req.query.skip ? parseInt(req.query.skip, 10) : 0;
        const sortField = req.query.sortBy;
        const sortDir = req.query.sortDir === 'desc' ? 'desc' : 'asc';

        const filter: Record<string, unknown> = {};
        for (const [key, value] of Object.entries(req.query)) {
          if (!['limit', 'skip', 'sortBy', 'sortDir'].includes(key)) {
            filter[key] = value;
          }
        }

        const results = await collection.find({
          filter: Object.keys(filter).length > 0 ? filter : undefined,
          limit,
          skip,
          sort: sortField ? { [sortField]: sortDir } : undefined,
        });

        res.status(200).json({ data: results, meta: { limit, skip } });
      } catch (error) {
        res.status(500).json({ error: 'Failed to list ${collection.name}' });
      }
    },

    /**
     * GET /${collection.name}/:id
     * Get a single document by ID.
     */
    async getById(req: APIRequest, res: APIResponse): Promise<void> {
      try {
        const { id } = req.params;
        if (!id) {
          res.status(400).json({ error: 'Missing id parameter' });
          return;
        }

        const doc = await collection.get(id);
        if (!doc) {
          res.status(404).json({ error: '${singular} not found' });
          return;
        }

        res.status(200).json({ data: doc });
      } catch (error) {
        res.status(500).json({ error: 'Failed to get ${singular.toLowerCase()}' });
      }
    },

    /**
     * POST /${collection.name}
     * Create a new document.
     */
    async create(req: APIRequest, res: APIResponse): Promise<void> {
      try {
        const body = req.body;
        if (!body || typeof body !== 'object') {
          res.status(400).json({ error: 'Request body is required' });
          return;
        }

        const doc = await collection.insert(body as Record<string, unknown>);
        res.status(201).json({ data: doc });
      } catch (error) {
        res.status(500).json({ error: 'Failed to create ${singular.toLowerCase()}' });
      }
    },

    /**
     * PUT /${collection.name}/:id
     * Update an existing document.
     */
    async update(req: APIRequest, res: APIResponse): Promise<void> {
      try {
        const { id } = req.params;
        if (!id) {
          res.status(400).json({ error: 'Missing id parameter' });
          return;
        }

        const body = req.body;
        if (!body || typeof body !== 'object') {
          res.status(400).json({ error: 'Request body is required' });
          return;
        }

        const doc = await collection.update(id, body as Record<string, unknown>);
        res.status(200).json({ data: doc });
      } catch (error) {
        res.status(500).json({ error: 'Failed to update ${singular.toLowerCase()}' });
      }
    },

    /**
     * DELETE /${collection.name}/:id
     * Delete a document by ID.
     */
    async remove(req: APIRequest, res: APIResponse): Promise<void> {
      try {
        const { id } = req.params;
        if (!id) {
          res.status(400).json({ error: 'Missing id parameter' });
          return;
        }

        await collection.delete(id);
        res.status(204).json(null);
      } catch (error) {
        res.status(500).json({ error: 'Failed to delete ${singular.toLowerCase()}' });
      }
    },
  };
}
`;
  }

  private generateRouterIndex(collections: string[]): string {
    const imports = collections
      .map((c) => {
        const singular = toPascalCase(c);
        return `export { create${singular}Routes } from './${c}.routes.js';`;
      })
      .join('\n');

    return `/**
 * Auto-generated API routes index
 * DO NOT EDIT - Generated by @pocket/codegen
 */

import type { Database } from '@pocket/core';

${imports}

export interface RouteHandler {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  path: string;
  handler: (req: unknown, res: unknown) => Promise<void>;
}

/**
 * Register all generated routes with a router-like interface.
 */
export function registerAllRoutes(
  db: Database,
  register: (method: string, path: string, handler: (...args: unknown[]) => Promise<void>) => void,
): void {
${collections
  .map((c) => {
    const singular = toPascalCase(c);
    return `  {
    const ${c}Routes = create${singular}Routes(db);
    register('GET', '/${c}', ${c}Routes.list as (...args: unknown[]) => Promise<void>);
    register('GET', '/${c}/:id', ${c}Routes.getById as (...args: unknown[]) => Promise<void>);
    register('POST', '/${c}', ${c}Routes.create as (...args: unknown[]) => Promise<void>);
    register('PUT', '/${c}/:id', ${c}Routes.update as (...args: unknown[]) => Promise<void>);
    register('DELETE', '/${c}/:id', ${c}Routes.remove as (...args: unknown[]) => Promise<void>);
  }`;
  })
  .join('\n\n')}
}
`;
  }
}

/**
 * Create an APIGenerator instance.
 */
export function createAPIGenerator(): APIGenerator {
  return new APIGenerator();
}
