/**
 * @pocket/codegen - React Generator
 *
 * Generates typed React hooks and components from Pocket collection schemas.
 *
 * @module @pocket/codegen
 */

import type { CollectionSchema, GeneratedFile, SchemaField } from '../types.js';

/**
 * Convert a collection name to PascalCase, removing trailing 's'.
 */
function toPascalCase(name: string): string {
  return name
    .split(/[-_\s]+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
    .replace(/s$/, '');
}

/**
 * Map a SchemaFieldType to a TypeScript type string.
 */
function fieldTypeToTS(field: SchemaField): string {
  switch (field.type) {
    case 'string':
      if (field.validation?.enum && field.validation.enum.length > 0) {
        return field.validation.enum.map((v) => JSON.stringify(v)).join(' | ');
      }
      return 'string';
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'date':
      return 'Date';
    case 'reference':
      return 'string';
    case 'array':
      return 'unknown[]';
    case 'object':
      return 'Record<string, unknown>';
    default:
      return 'unknown';
  }
}

/**
 * ReactGenerator produces typed React hooks and components
 * from Pocket collection schemas.
 */
export class ReactGenerator {
  /**
   * Generate typed React hooks for a collection schema.
   *
   * Produces `useCollectionQuery`, `useCollectionDocument`, and
   * `useCollectionMutation` hooks wrapping Pocket's live query,
   * document, and mutation APIs with full type safety.
   *
   * @param schema - Collection schema to generate hooks for
   * @returns Generated file containing the hooks
   */
  generateHooks(schema: CollectionSchema): GeneratedFile {
    const singular = toPascalCase(schema.name);

    const lines: string[] = [
      `/**`,
      ` * Auto-generated React hooks for the "${schema.name}" collection`,
      ` *`,
      ` * DO NOT EDIT - This file is auto-generated by @pocket/codegen`,
      ` */`,
      ``,
      `import { useLiveQuery, useDocument, useMutation } from '@pocket/react';`,
      `import type { ${singular} } from '../types/${schema.name}.types.js';`,
      ``,
      this.generateQueryHook(schema, singular),
      ``,
      this.generateDocumentHook(schema, singular),
      ``,
      this.generateMutationHook(schema, singular),
      ``,
    ];

    return {
      path: `hooks/use${singular}.ts`,
      content: lines.join('\n'),
      type: 'hooks',
    };
  }

  /**
   * Generate a typed form component for a collection schema.
   *
   * Produces a React component with form fields derived from the
   * schema field definitions, including appropriate input types.
   *
   * @param schema - Collection schema to generate the form for
   * @returns Generated file containing the form component
   */
  generateFormComponent(schema: CollectionSchema): GeneratedFile {
    const singular = toPascalCase(schema.name);

    const lines: string[] = [
      `/**`,
      ` * Auto-generated form component for the "${schema.name}" collection`,
      ` *`,
      ` * DO NOT EDIT - This file is auto-generated by @pocket/codegen`,
      ` */`,
      ``,
      `import React, { useState, useCallback } from 'react';`,
      `import type { ${singular} } from '../types/${schema.name}.types.js';`,
      ``,
      `export interface ${singular}FormProps {`,
      `  initialValues?: Partial<${singular}>;`,
      `  onSubmit: (values: Omit<${singular}, '_id'>) => void;`,
      `  onCancel?: () => void;`,
      `}`,
      ``,
      `export function ${singular}Form({ initialValues, onSubmit, onCancel }: ${singular}FormProps) {`,
    ];

    // Generate state for each field
    for (const [fieldName, field] of Object.entries(schema.fields)) {
      const defaultValue = this.getDefaultValue(field);
      lines.push(`  const [${fieldName}, set${this.capitalize(fieldName)}] = useState<${fieldTypeToTS(field)}>(initialValues?.${fieldName} ?? ${defaultValue});`);
    }

    lines.push(``);
    lines.push(`  const handleSubmit = useCallback((e: React.FormEvent) => {`);
    lines.push(`    e.preventDefault();`);
    lines.push(`    onSubmit({`);

    for (const fieldName of Object.keys(schema.fields)) {
      lines.push(`      ${fieldName},`);
    }

    lines.push(`    } as Omit<${singular}, '_id'>);`);
    lines.push(`  }, [${Object.keys(schema.fields).join(', ')}, onSubmit]);`);
    lines.push(``);
    lines.push(`  return (`);
    lines.push(`    <form onSubmit={handleSubmit}>`);

    // Generate form fields
    for (const [fieldName, field] of Object.entries(schema.fields)) {
      lines.push(`      <div>`);
      lines.push(`        <label htmlFor="${fieldName}">${fieldName}</label>`);
      lines.push(`        ${this.generateInput(fieldName, field)}`);
      lines.push(`      </div>`);
    }

    lines.push(`      <button type="submit">Submit</button>`);
    lines.push(`      {onCancel && <button type="button" onClick={onCancel}>Cancel</button>}`);
    lines.push(`    </form>`);
    lines.push(`  );`);
    lines.push(`}`);
    lines.push(``);

    return {
      path: `components/${singular}Form.tsx`,
      content: lines.join('\n'),
      type: 'hooks',
    };
  }

  /**
   * Generate a typed list component for a collection schema.
   *
   * Produces a React component that displays a list of documents
   * with sort and filter support.
   *
   * @param schema - Collection schema to generate the list for
   * @returns Generated file containing the list component
   */
  generateListComponent(schema: CollectionSchema): GeneratedFile {
    const singular = toPascalCase(schema.name);
    const fieldNames = Object.keys(schema.fields);

    const lines: string[] = [
      `/**`,
      ` * Auto-generated list component for the "${schema.name}" collection`,
      ` *`,
      ` * DO NOT EDIT - This file is auto-generated by @pocket/codegen`,
      ` */`,
      ``,
      `import React, { useState, useMemo } from 'react';`,
      `import type { ${singular} } from '../types/${schema.name}.types.js';`,
      ``,
      `export interface ${singular}ListProps {`,
      `  items: ${singular}[];`,
      `  onSelect?: (item: ${singular}) => void;`,
      `  onDelete?: (id: string) => void;`,
      `}`,
      ``,
      `type SortField = ${fieldNames.map((f) => `'${f}'`).join(' | ')};`,
      `type SortDirection = 'asc' | 'desc';`,
      ``,
      `export function ${singular}List({ items, onSelect, onDelete }: ${singular}ListProps) {`,
      `  const [sortField, setSortField] = useState<SortField>('${fieldNames[0]}');`,
      `  const [sortDirection, setSortDirection] = useState<SortDirection>('asc');`,
      `  const [filterText, setFilterText] = useState('');`,
      ``,
      `  const filteredAndSorted = useMemo(() => {`,
      `    let result = items;`,
      `    if (filterText) {`,
      `      const lower = filterText.toLowerCase();`,
      `      result = result.filter((item) =>`,
      `        Object.values(item).some((v) => String(v).toLowerCase().includes(lower))`,
      `      );`,
      `    }`,
      `    result = [...result].sort((a, b) => {`,
      `      const aVal = (a as Record<string, unknown>)[sortField];`,
      `      const bVal = (b as Record<string, unknown>)[sortField];`,
      `      const cmp = String(aVal ?? '').localeCompare(String(bVal ?? ''));`,
      `      return sortDirection === 'asc' ? cmp : -cmp;`,
      `    });`,
      `    return result;`,
      `  }, [items, sortField, sortDirection, filterText]);`,
      ``,
      `  const toggleSort = (field: SortField) => {`,
      `    if (sortField === field) {`,
      `      setSortDirection((d) => (d === 'asc' ? 'desc' : 'asc'));`,
      `    } else {`,
      `      setSortField(field);`,
      `      setSortDirection('asc');`,
      `    }`,
      `  };`,
      ``,
      `  return (`,
      `    <div>`,
      `      <input`,
      `        type="text"`,
      `        placeholder="Filter..."`,
      `        value={filterText}`,
      `        onChange={(e) => setFilterText(e.target.value)}`,
      `      />`,
      `      <table>`,
      `        <thead>`,
      `          <tr>`,
    ];

    for (const fieldName of fieldNames) {
      lines.push(`            <th onClick={() => toggleSort('${fieldName}')}>${fieldName}</th>`);
    }

    lines.push(`            <th>Actions</th>`);
    lines.push(`          </tr>`);
    lines.push(`        </thead>`);
    lines.push(`        <tbody>`);
    lines.push(`          {filteredAndSorted.map((item) => (`);
    lines.push(`            <tr key={(item as Record<string, unknown>)._id as string} onClick={() => onSelect?.(item)}>`);

    for (const fieldName of fieldNames) {
      lines.push(`              <td>{String((item as Record<string, unknown>).${fieldName} ?? '')}</td>`);
    }

    lines.push(`              <td>`);
    lines.push(`                {onDelete && (`);
    lines.push(`                  <button onClick={(e) => { e.stopPropagation(); onDelete((item as Record<string, unknown>)._id as string); }}>Delete</button>`);
    lines.push(`                )}`);
    lines.push(`              </td>`);
    lines.push(`            </tr>`);
    lines.push(`          ))}`);
    lines.push(`        </tbody>`);
    lines.push(`      </table>`);
    lines.push(`    </div>`);
    lines.push(`  );`);
    lines.push(`}`);
    lines.push(``);

    return {
      path: `components/${singular}List.tsx`,
      content: lines.join('\n'),
      type: 'hooks',
    };
  }

  private generateQueryHook(schema: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Query ${schema.name} with live updates.`,
      ` */`,
      `export function use${singular}Query(`,
      `  filter?: Partial<${singular}>`,
      `) {`,
      `  return useLiveQuery<${singular}>('${schema.name}', { filter });`,
      `}`,
    ].join('\n');
  }

  private generateDocumentHook(schema: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Get a single ${singular.toLowerCase()} by ID with live updates.`,
      ` */`,
      `export function use${singular}Document(`,
      `  id: string | null`,
      `) {`,
      `  return useDocument<${singular}>('${schema.name}', id);`,
      `}`,
    ].join('\n');
  }

  private generateMutationHook(schema: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Mutation hook for ${schema.name} (insert, update, delete).`,
      ` */`,
      `export function use${singular}Mutation() {`,
      `  return useMutation<${singular}>('${schema.name}');`,
      `}`,
    ].join('\n');
  }

  private generateInput(fieldName: string, field: SchemaField): string {
    const setter = `set${this.capitalize(fieldName)}`;
    switch (field.type) {
      case 'boolean':
        return `<input id="${fieldName}" type="checkbox" checked={${fieldName}} onChange={(e) => ${setter}(e.target.checked)} />`;
      case 'number':
        return `<input id="${fieldName}" type="number" value={${fieldName}} onChange={(e) => ${setter}(Number(e.target.value))} />`;
      case 'date':
        return `<input id="${fieldName}" type="date" value={${fieldName} instanceof Date ? ${fieldName}.toISOString().slice(0, 10) : ''} onChange={(e) => ${setter}(new Date(e.target.value))} />`;
      default:
        return `<input id="${fieldName}" type="text" value={String(${fieldName} ?? '')} onChange={(e) => ${setter}(e.target.value)} />`;
    }
  }

  private getDefaultValue(field: SchemaField): string {
    if (field.default !== undefined) return JSON.stringify(field.default);
    switch (field.type) {
      case 'string':
        return "''";
      case 'number':
        return '0';
      case 'boolean':
        return 'false';
      case 'date':
        return 'new Date()';
      case 'array':
        return '[]';
      case 'object':
        return '{}';
      default:
        return "''";
    }
  }

  private capitalize(s: string): string {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
}

/**
 * Create a ReactGenerator instance.
 */
export function createReactGenerator(): ReactGenerator {
  return new ReactGenerator();
}
