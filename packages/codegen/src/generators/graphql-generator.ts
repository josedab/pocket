/**
 * @pocket/codegen - GraphQL Resolver Generator
 *
 * Generates GraphQL type definitions (SDL) and resolver implementations
 * from Pocket collection schemas. Supports queries, mutations,
 * subscriptions, and relation resolution.
 *
 * @module @pocket/codegen
 */

import type { CollectionSchema, GeneratedFile, SchemaField, SchemaFieldType } from '../types.js';

/** Configuration for the GraphQL generator */
export interface GraphQLGeneratorConfig {
  /** Include subscription resolvers (default: true) */
  readonly subscriptions?: boolean;
  /** Include relay-style pagination (default: true) */
  readonly relayPagination?: boolean;
  /** Include input types for mutations (default: true) */
  readonly inputTypes?: boolean;
  /** Header comment for generated files */
  readonly headerComment?: string;
}

// ── Helpers ──────────────────────────────────────────────────────────────────

function toPascalCase(name: string): string {
  return name
    .split(/[-_\s]+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
    .replace(/s$/, '');
}

function toCamelCase(name: string): string {
  const pascal = toPascalCase(name);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function fieldTypeToGraphQL(field: SchemaField): string {
  const typeMap: Record<SchemaFieldType, string> = {
    string: 'String',
    number: field.validation?.min !== undefined && Number.isInteger(field.validation.min)
      ? 'Int' : 'Float',
    boolean: 'Boolean',
    date: 'DateTime',
    reference: 'ID',
    array: 'String',
    object: 'JSON',
  };

  let gqlType = typeMap[field.type] ?? 'String';

  if (field.type === 'array' && field.items) {
    const itemType = fieldTypeToGraphQL(field.items);
    gqlType = `[${itemType}]`;
  }

  if (field.validation?.enum && field.validation.enum.length > 0) {
    return 'String'; // Could be an enum but kept as String for simplicity
  }

  return field.required ? `${gqlType}!` : gqlType;
}

function fieldTypeToInputGraphQL(field: SchemaField): string {
  const base = fieldTypeToGraphQL(field);
  // Input types are never required (for update mutations)
  return base.replace(/!$/, '');
}

// ── Generator ────────────────────────────────────────────────────────────────

/**
 * Generates GraphQL schema (SDL) and resolver code from Pocket schemas.
 *
 * @example
 * ```typescript
 * import { GraphQLGenerator } from '@pocket/codegen';
 *
 * const generator = new GraphQLGenerator({ subscriptions: true });
 * const files = generator.generate(schema.collections);
 * // files[0] -> schema.graphql (SDL)
 * // files[1] -> resolvers.ts (TypeScript resolvers)
 * ```
 */
export class GraphQLGenerator {
  private readonly config: Required<GraphQLGeneratorConfig>;

  constructor(config: GraphQLGeneratorConfig = {}) {
    this.config = {
      subscriptions: config.subscriptions ?? true,
      relayPagination: config.relayPagination ?? true,
      inputTypes: config.inputTypes ?? true,
      headerComment: config.headerComment ?? '# Generated by @pocket/codegen — DO NOT EDIT',
    };
  }

  /** Generate GraphQL SDL and resolver files from collection schemas */
  generate(collections: CollectionSchema[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    files.push({
      path: 'schema.graphql',
      content: this.generateSDL(collections),
      type: 'types',
    });

    files.push({
      path: 'resolvers.ts',
      content: this.generateResolvers(collections),
      type: 'hooks',
    });

    return files;
  }

  /** Generate only the SDL string */
  generateSDL(collections: CollectionSchema[]): string {
    const lines: string[] = [this.config.headerComment, ''];

    // Scalar types
    lines.push('scalar DateTime');
    lines.push('scalar JSON');
    lines.push('');

    // Type definitions for each collection
    for (const coll of collections) {
      lines.push(...this.generateTypeSDL(coll));
      lines.push('');
    }

    // Input types
    if (this.config.inputTypes) {
      for (const coll of collections) {
        lines.push(...this.generateInputSDL(coll));
        lines.push('');
      }
    }

    // Relay connection types
    if (this.config.relayPagination) {
      for (const coll of collections) {
        lines.push(...this.generateConnectionSDL(coll));
        lines.push('');
      }
      lines.push('type PageInfo {');
      lines.push('  hasNextPage: Boolean!');
      lines.push('  hasPreviousPage: Boolean!');
      lines.push('  startCursor: String');
      lines.push('  endCursor: String');
      lines.push('}');
      lines.push('');
    }

    // Query type
    lines.push('type Query {');
    for (const coll of collections) {
      const typeName = toPascalCase(coll.name);
      const camelName = toCamelCase(coll.name);
      lines.push(`  ${camelName}(id: ID!): ${typeName}`);
      if (this.config.relayPagination) {
        lines.push(
          `  ${coll.name}(first: Int, after: String, last: Int, before: String, filter: ${typeName}FilterInput): ${typeName}Connection!`,
        );
      } else {
        lines.push(`  ${coll.name}(limit: Int, offset: Int): [${typeName}!]!`);
      }
    }
    lines.push('}');
    lines.push('');

    // Mutation type
    lines.push('type Mutation {');
    for (const coll of collections) {
      const typeName = toPascalCase(coll.name);
      lines.push(`  create${typeName}(input: Create${typeName}Input!): ${typeName}!`);
      lines.push(`  update${typeName}(id: ID!, input: Update${typeName}Input!): ${typeName}`);
      lines.push(`  delete${typeName}(id: ID!): Boolean!`);

      // Bulk operations
      lines.push(`  bulkDelete${typeName}s(ids: [ID!]!): Int!`);
    }
    lines.push('}');
    lines.push('');

    // Subscription type
    if (this.config.subscriptions) {
      lines.push('type Subscription {');
      for (const coll of collections) {
        const typeName = toPascalCase(coll.name);
        const camelName = toCamelCase(coll.name);
        lines.push(`  ${camelName}Created: ${typeName}!`);
        lines.push(`  ${camelName}Updated: ${typeName}!`);
        lines.push(`  ${camelName}Deleted: ID!`);
      }
      lines.push('}');
      lines.push('');
    }

    // Filter input types
    for (const coll of collections) {
      lines.push(...this.generateFilterInputSDL(coll));
      lines.push('');
    }

    return lines.join('\n');
  }

  /** Generate resolver TypeScript code */
  generateResolvers(collections: CollectionSchema[]): string {
    const lines: string[] = [
      '// Generated by @pocket/codegen — DO NOT EDIT',
      '',
      "import type { Database } from '@pocket/core';",
      '',
      'type Context = { db: Database };',
      '',
    ];

    // Query resolvers
    lines.push('export const resolvers = {');
    lines.push('  Query: {');
    for (const coll of collections) {
      const camelName = toCamelCase(coll.name);
      lines.push(
        `    ${camelName}: async (_: unknown, { id }: { id: string }, { db }: Context) => {`,
      );
      lines.push(`      const collection = db.collection('${coll.name}');`);
      lines.push('      return collection.get(id);');
      lines.push('    },');
      lines.push(
        `    ${coll.name}: async (_: unknown, args: { limit?: number; offset?: number }, { db }: Context) => {`,
      );
      lines.push(`      const collection = db.collection('${coll.name}');`);
      lines.push(
        '      return collection.find({ limit: args.limit ?? 50, skip: args.offset ?? 0 });',
      );
      lines.push('    },');
    }
    lines.push('  },');
    lines.push('');

    // Mutation resolvers
    lines.push('  Mutation: {');
    for (const coll of collections) {
      const typeName = toPascalCase(coll.name);
      lines.push(
        `    create${typeName}: async (_: unknown, { input }: { input: Record<string, unknown> }, { db }: Context) => {`,
      );
      lines.push(`      const collection = db.collection('${coll.name}');`);
      lines.push(
        "      const id = typeof crypto !== 'undefined' ? crypto.randomUUID() : Math.random().toString(36).slice(2);",
      );
      lines.push('      await collection.insert({ _id: id, ...input });');
      lines.push('      return collection.get(id);');
      lines.push('    },');
      lines.push(
        `    update${typeName}: async (_: unknown, { id, input }: { id: string; input: Record<string, unknown> }, { db }: Context) => {`,
      );
      lines.push(`      const collection = db.collection('${coll.name}');`);
      lines.push('      await collection.update(id, input);');
      lines.push('      return collection.get(id);');
      lines.push('    },');
      lines.push(
        `    delete${typeName}: async (_: unknown, { id }: { id: string }, { db }: Context) => {`,
      );
      lines.push(`      const collection = db.collection('${coll.name}');`);
      lines.push('      await collection.delete(id);');
      lines.push('      return true;');
      lines.push('    },');
      lines.push(
        `    bulkDelete${typeName}s: async (_: unknown, { ids }: { ids: string[] }, { db }: Context) => {`,
      );
      lines.push(`      const collection = db.collection('${coll.name}');`);
      lines.push('      for (const id of ids) { await collection.delete(id); }');
      lines.push('      return ids.length;');
      lines.push('    },');
    }
    lines.push('  },');
    lines.push('};');

    return lines.join('\n');
  }

  // ── Private SDL Generators ─────────────────────────────────────────────

  private generateTypeSDL(coll: CollectionSchema): string[] {
    const typeName = toPascalCase(coll.name);
    const lines: string[] = [`type ${typeName} {`, '  _id: ID!'];

    const fields = coll.fields ?? {};
    for (const [fieldName, field] of Object.entries(fields)) {
      lines.push(`  ${fieldName}: ${fieldTypeToGraphQL(field)}`);
    }

    lines.push('  _createdAt: DateTime');
    lines.push('  _updatedAt: DateTime');
    lines.push('}');
    return lines;
  }

  private generateInputSDL(coll: CollectionSchema): string[] {
    const typeName = toPascalCase(coll.name);
    const fields = coll.fields ?? {};
    const lines: string[] = [];

    // Create input
    lines.push(`input Create${typeName}Input {`);
    for (const [fieldName, field] of Object.entries(fields)) {
      lines.push(`  ${fieldName}: ${fieldTypeToGraphQL(field)}`);
    }
    lines.push('}');
    lines.push('');

    // Update input (all optional)
    lines.push(`input Update${typeName}Input {`);
    for (const [fieldName, field] of Object.entries(fields)) {
      lines.push(`  ${fieldName}: ${fieldTypeToInputGraphQL(field)}`);
    }
    lines.push('}');

    return lines;
  }

  private generateConnectionSDL(coll: CollectionSchema): string[] {
    const typeName = toPascalCase(coll.name);
    return [
      `type ${typeName}Connection {`,
      `  edges: [${typeName}Edge!]!`,
      '  pageInfo: PageInfo!',
      '  totalCount: Int!',
      '}',
      '',
      `type ${typeName}Edge {`,
      `  node: ${typeName}!`,
      '  cursor: String!',
      '}',
    ];
  }

  private generateFilterInputSDL(coll: CollectionSchema): string[] {
    const typeName = toPascalCase(coll.name);
    const fields = coll.fields ?? {};
    const lines: string[] = [`input ${typeName}FilterInput {`];

    for (const [fieldName, field] of Object.entries(fields)) {
      const gqlType = fieldTypeToGraphQL(field).replace(/!$/, '');
      lines.push(`  ${fieldName}: ${gqlType}`);
      if (field.type === 'string') {
        lines.push(`  ${fieldName}_contains: String`);
        lines.push(`  ${fieldName}_startsWith: String`);
      }
      if (field.type === 'number' || field.type === 'date') {
        lines.push(`  ${fieldName}_gt: ${gqlType}`);
        lines.push(`  ${fieldName}_gte: ${gqlType}`);
        lines.push(`  ${fieldName}_lt: ${gqlType}`);
        lines.push(`  ${fieldName}_lte: ${gqlType}`);
      }
    }

    lines.push('}');
    return lines;
  }
}

/** Factory function to create a GraphQLGenerator */
export function createGraphQLGenerator(
  config?: GraphQLGeneratorConfig,
): GraphQLGenerator {
  return new GraphQLGenerator(config);
}
