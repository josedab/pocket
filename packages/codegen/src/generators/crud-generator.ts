/**
 * @pocket/codegen - CRUD Generator
 *
 * Generates type-safe CRUD operation functions for Pocket collections.
 *
 * @module @pocket/codegen
 */

import type { CollectionSchema, GeneratedFile, SchemaField } from '../types.js';

/**
 * Convert a collection name to PascalCase, removing trailing 's'.
 */
function toPascalCase(name: string): string {
  return name
    .split(/[-_\s]+/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
    .replace(/s$/, '');
}

/**
 * Convert a collection name to a singular PascalCase form.
 */
function toSingular(name: string): string {
  return toPascalCase(name);
}

/**
 * Map a SchemaFieldType to a TypeScript type string.
 */
function fieldTypeToTS(field: SchemaField): string {
  switch (field.type) {
    case 'string':
      if (field.validation?.enum && field.validation.enum.length > 0) {
        return field.validation.enum.map((v) => JSON.stringify(v)).join(' | ');
      }
      return 'string';
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'date':
      return 'Date';
    case 'reference':
      return 'string';
    case 'array':
      return 'unknown[]';
    case 'object':
      return 'Record<string, unknown>';
    default:
      return 'unknown';
  }
}

/**
 * CRUDGenerator produces type-safe CRUD operation functions
 * from Pocket collection schemas.
 */
export class CRUDGenerator {
  /**
   * Generate CRUD operation files for a set of collections.
   *
   * Produces one file per collection with typed insert, get, update,
   * delete, list, and count functions, plus an index file.
   *
   * @param collections - Collection schemas to generate CRUD operations for
   * @returns Array of generated files
   */
  generateCRUD(collections: CollectionSchema[]): GeneratedFile[] {
    const files: GeneratedFile[] = [];
    const exportEntries: { fileName: string; names: string[] }[] = [];

    for (const collection of collections) {
      const singular = toSingular(collection.name);
      const fileName = `${collection.name}.crud`;

      const content = this.generateCRUDFile(collection);
      files.push({
        path: `crud/${fileName}.ts`,
        content,
        type: 'crud',
      });

      exportEntries.push({
        fileName,
        names: [
          `Create${singular}Input`,
          `Update${singular}Input`,
          `${singular}Filters`,
          `create${singular}`,
          `get${singular}`,
          `update${singular}`,
          `delete${singular}`,
          `list${singular}s`,
          `count${singular}s`,
        ],
      });
    }

    // Generate index file
    const indexContent = this.generateCRUDIndex(exportEntries);
    files.push({
      path: 'crud/index.ts',
      content: indexContent,
      type: 'index',
    });

    return files;
  }

  /**
   * Generate the CRUD file for a single collection.
   */
  private generateCRUDFile(collection: CollectionSchema): string {
    const singular = toSingular(collection.name);

    const lines: string[] = [
      `/**`,
      ` * Auto-generated CRUD operations for the "${collection.name}" collection`,
      ` *`,
      ` * DO NOT EDIT - This file is auto-generated by @pocket/codegen`,
      ` */`,
      ``,
      `import type { Database } from '@pocket/core';`,
      `import type { ${singular} } from '../types/${collection.name}.types.js';`,
      ``,
      this.generateCreateInput(collection, singular),
      ``,
      this.generateUpdateInput(collection, singular),
      ``,
      this.generateFilters(collection, singular),
      ``,
      this.generateCreateFn(collection, singular),
      ``,
      this.generateGetFn(collection, singular),
      ``,
      this.generateUpdateFn(collection, singular),
      ``,
      this.generateDeleteFn(collection, singular),
      ``,
      this.generateListFn(collection, singular),
      ``,
      this.generateCountFn(collection, singular),
      ``,
    ];

    return lines.join('\n');
  }

  private generateCreateInput(collection: CollectionSchema, singular: string): string {
    const lines: string[] = [];
    lines.push(`export interface Create${singular}Input {`);

    for (const [fieldName, field] of Object.entries(collection.fields)) {
      const optional = field.required ? '' : '?';
      lines.push(`  ${fieldName}${optional}: ${fieldTypeToTS(field)};`);
    }

    lines.push(`}`);
    return lines.join('\n');
  }

  private generateUpdateInput(collection: CollectionSchema, singular: string): string {
    const lines: string[] = [];
    lines.push(`export interface Update${singular}Input {`);

    for (const [fieldName, field] of Object.entries(collection.fields)) {
      lines.push(`  ${fieldName}?: ${fieldTypeToTS(field)};`);
    }

    lines.push(`}`);
    return lines.join('\n');
  }

  private generateFilters(collection: CollectionSchema, singular: string): string {
    const lines: string[] = [];
    lines.push(`export interface ${singular}Filters {`);

    for (const [fieldName, field] of Object.entries(collection.fields)) {
      if (['string', 'number', 'boolean', 'date', 'reference'].includes(field.type)) {
        lines.push(`  ${fieldName}?: ${fieldTypeToTS(field)};`);
      }
    }

    lines.push(`  _limit?: number;`);
    lines.push(`  _skip?: number;`);
    lines.push(`  _sort?: Record<string, 'asc' | 'desc'>;`);
    lines.push(`}`);
    return lines.join('\n');
  }

  private generateCreateFn(collection: CollectionSchema, singular: string): string {
    const defaultLines: string[] = [];
    for (const [fieldName, field] of Object.entries(collection.fields)) {
      if (field.default !== undefined) {
        defaultLines.push(`    ${fieldName}: input.${fieldName} ?? ${JSON.stringify(field.default)},`);
      }
    }

    const lines: string[] = [
      `/**`,
      ` * Create a new ${singular.toLowerCase()}.`,
      ` */`,
      `export async function create${singular}(`,
      `  db: Database,`,
      `  input: Create${singular}Input`,
      `): Promise<${singular}> {`,
      `  const collection = db.collection<${singular}>('${collection.name}');`,
      `  return collection.insert({`,
      `    _id: crypto.randomUUID(),`,
      `    ...input,`,
    ];

    if (defaultLines.length > 0) {
      lines.push(...defaultLines);
    }

    lines.push(`  } as unknown as ${singular});`);
    lines.push(`}`);
    return lines.join('\n');
  }

  private generateGetFn(collection: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Get a ${singular.toLowerCase()} by ID.`,
      ` */`,
      `export async function get${singular}(`,
      `  db: Database,`,
      `  id: string`,
      `): Promise<${singular} | null> {`,
      `  const collection = db.collection<${singular}>('${collection.name}');`,
      `  return collection.get(id);`,
      `}`,
    ].join('\n');
  }

  private generateUpdateFn(collection: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Update a ${singular.toLowerCase()} by ID.`,
      ` */`,
      `export async function update${singular}(`,
      `  db: Database,`,
      `  id: string,`,
      `  input: Update${singular}Input`,
      `): Promise<${singular}> {`,
      `  const collection = db.collection<${singular}>('${collection.name}');`,
      `  return collection.update(id, input);`,
      `}`,
    ].join('\n');
  }

  private generateDeleteFn(collection: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Delete a ${singular.toLowerCase()} by ID.`,
      ` */`,
      `export async function delete${singular}(`,
      `  db: Database,`,
      `  id: string`,
      `): Promise<void> {`,
      `  const collection = db.collection<${singular}>('${collection.name}');`,
      `  await collection.delete(id);`,
      `}`,
    ].join('\n');
  }

  private generateListFn(collection: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * List ${collection.name} with optional filters.`,
      ` */`,
      `export async function list${singular}s(`,
      `  db: Database,`,
      `  filters?: ${singular}Filters`,
      `): Promise<${singular}[]> {`,
      `  const collection = db.collection<${singular}>('${collection.name}');`,
      `  const { _limit, _skip, _sort, ...fieldFilters } = filters ?? {};`,
      `  return collection.find({`,
      `    filter: Object.keys(fieldFilters).length > 0 ? fieldFilters : undefined,`,
      `    limit: _limit,`,
      `    skip: _skip,`,
      `    sort: _sort,`,
      `  });`,
      `}`,
    ].join('\n');
  }

  private generateCountFn(collection: CollectionSchema, singular: string): string {
    return [
      `/**`,
      ` * Count ${collection.name} with optional filters.`,
      ` */`,
      `export async function count${singular}s(`,
      `  db: Database,`,
      `  filters?: Omit<${singular}Filters, '_limit' | '_skip' | '_sort'>`,
      `): Promise<number> {`,
      `  const collection = db.collection<${singular}>('${collection.name}');`,
      `  const results = await collection.find({`,
      `    filter: filters && Object.keys(filters).length > 0 ? filters : undefined,`,
      `  });`,
      `  return results.length;`,
      `}`,
    ].join('\n');
  }

  /**
   * Generate the index file for CRUD operations.
   */
  private generateCRUDIndex(
    exports: { fileName: string; names: string[] }[]
  ): string {
    const lines: string[] = [
      `/**`,
      ` * Auto-generated CRUD operations index`,
      ` *`,
      ` * DO NOT EDIT - This file is auto-generated by @pocket/codegen`,
      ` */`,
      ``,
    ];

    for (const { fileName, names } of exports) {
      lines.push(`export { ${names.join(', ')} } from './${fileName}.js';`);
    }

    lines.push(``);
    return lines.join('\n');
  }
}
