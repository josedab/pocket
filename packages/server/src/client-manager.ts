import type { Checkpoint } from '@pocket/sync';
import type { WebSocket } from 'ws';

/**
 * Information about a connected WebSocket client.
 *
 * Tracks the client's identity, connection state, subscriptions,
 * and sync checkpoint for efficient change routing.
 *
 * @see {@link ClientManager} for managing connected clients
 */
export interface ConnectedClient {
  /**
   * Unique identifier for this connection.
   * Generated by the server when the client connects.
   */
  id: string;

  /**
   * The WebSocket connection for this client.
   * Used to send messages and check connection state.
   */
  socket: WebSocket;

  /**
   * Client's node ID for distributed sync.
   * This is the client's self-assigned identifier used for
   * conflict resolution and vector clocks.
   */
  nodeId: string;

  /**
   * Set of collection names the client is actively syncing.
   * Used to route change broadcasts efficiently.
   */
  collections: Set<string>;

  /**
   * Client's last known sync checkpoint.
   * Used to determine which changes to send on pull requests.
   */
  checkpoint: Checkpoint | null;

  /**
   * Unix timestamp when the client connected.
   */
  connectedAt: number;

  /**
   * Unix timestamp of the client's last activity.
   * Updated on each message received. Used for timeout cleanup.
   */
  lastActiveAt: number;

  /**
   * Authenticated user ID, if authentication is enabled.
   * Undefined for unauthenticated connections.
   */
  userId?: string;

  /**
   * Custom metadata associated with this client.
   * Populated from the authenticate function's return value.
   */
  metadata: Record<string, unknown>;
}

/**
 * Manages connected WebSocket clients for the sync server.
 *
 * ClientManager provides efficient lookups for:
 * - Finding all clients for a specific user (multi-device support)
 * - Finding all clients subscribed to a collection (for broadcasting)
 * - Tracking client activity for timeout cleanup
 *
 * The manager maintains three indexes:
 * - `clients`: All clients by client ID (primary index)
 * - `clientsByUser`: Client IDs grouped by user ID
 * - `clientsByCollection`: Client IDs grouped by collection name
 *
 * @example
 * ```typescript
 * const manager = new ClientManager();
 *
 * // Add a client
 * const client = manager.add({
 *   id: 'client-123',
 *   socket: ws,
 *   nodeId: 'node-abc',
 *   collections: new Set(['todos']),
 *   checkpoint: null,
 *   userId: 'user-1',
 *   metadata: {}
 * });
 *
 * // Find clients for broadcasting
 * const otherClients = manager.getOthers('client-123', 'todos');
 *
 * // Cleanup inactive clients
 * const removed = manager.removeInactive(60000);
 * ```
 *
 * @see {@link PocketServer} for how this is used
 */
export class ClientManager {
  /** Primary index: client ID -> ConnectedClient */
  private clients = new Map<string, ConnectedClient>();

  /** Index for user lookups: user ID -> Set of client IDs */
  private clientsByUser = new Map<string, Set<string>>();

  /** Index for collection lookups: collection name -> Set of client IDs */
  private clientsByCollection = new Map<string, Set<string>>();

  /**
   * Register a new connected client.
   *
   * Automatically:
   * - Sets connectedAt and lastActiveAt to current time
   * - Adds to user index (if userId provided)
   * - Adds to collection indexes (for each collection in set)
   *
   * @param client - Client info (without timestamps)
   * @returns The complete client object with timestamps
   */
  add(client: Omit<ConnectedClient, 'connectedAt' | 'lastActiveAt'>): ConnectedClient {
    const fullClient: ConnectedClient = {
      ...client,
      connectedAt: Date.now(),
      lastActiveAt: Date.now(),
    };

    this.clients.set(client.id, fullClient);

    // Track by user
    if (client.userId) {
      let userClients = this.clientsByUser.get(client.userId);
      if (!userClients) {
        userClients = new Set();
        this.clientsByUser.set(client.userId, userClients);
      }
      userClients.add(client.id);
    }

    // Track by collection
    for (const collection of client.collections) {
      let collectionClients = this.clientsByCollection.get(collection);
      if (!collectionClients) {
        collectionClients = new Set();
        this.clientsByCollection.set(collection, collectionClients);
      }
      collectionClients.add(client.id);
    }

    return fullClient;
  }

  /**
   * Get a client by their connection ID.
   *
   * @param id - The client's unique connection ID
   * @returns The client if found, undefined otherwise
   */
  get(id: string): ConnectedClient | undefined {
    return this.clients.get(id);
  }

  /**
   * Remove a client and clean up all indexes.
   *
   * Called when a client disconnects or times out.
   * Removes the client from:
   * - Primary clients map
   * - User index
   * - All collection indexes
   *
   * @param id - The client ID to remove
   * @returns true if the client was removed, false if not found
   */
  remove(id: string): boolean {
    const client = this.clients.get(id);
    if (!client) return false;

    this.clients.delete(id);

    // Remove from user tracking
    if (client.userId) {
      const userClients = this.clientsByUser.get(client.userId);
      if (userClients) {
        userClients.delete(id);
        if (userClients.size === 0) {
          this.clientsByUser.delete(client.userId);
        }
      }
    }

    // Remove from collection tracking
    for (const collection of client.collections) {
      const collectionClients = this.clientsByCollection.get(collection);
      if (collectionClients) {
        collectionClients.delete(id);
        if (collectionClients.size === 0) {
          this.clientsByCollection.delete(collection);
        }
      }
    }

    return true;
  }

  /**
   * Update a client's last activity timestamp.
   *
   * Call this whenever a message is received from the client
   * to prevent timeout disconnection.
   *
   * @param id - The client ID to touch
   */
  touch(id: string): void {
    const client = this.clients.get(id);
    if (client) {
      client.lastActiveAt = Date.now();
    }
  }

  /**
   * Update a client's sync checkpoint.
   *
   * Also updates lastActiveAt since checkpoint updates
   * typically come with sync messages.
   *
   * @param id - The client ID
   * @param checkpoint - The new checkpoint value
   */
  updateCheckpoint(id: string, checkpoint: Checkpoint): void {
    const client = this.clients.get(id);
    if (client) {
      client.checkpoint = checkpoint;
      client.lastActiveAt = Date.now();
    }
  }

  /**
   * Add collections to a client's subscription list.
   *
   * When a client starts syncing additional collections, call this
   * to ensure they receive broadcasts for those collections.
   *
   * @param id - The client ID
   * @param collections - Collection names to add
   */
  addCollections(id: string, collections: string[]): void {
    const client = this.clients.get(id);
    if (!client) return;

    for (const collection of collections) {
      if (!client.collections.has(collection)) {
        client.collections.add(collection);

        let collectionClients = this.clientsByCollection.get(collection);
        if (!collectionClients) {
          collectionClients = new Set();
          this.clientsByCollection.set(collection, collectionClients);
        }
        collectionClients.add(id);
      }
    }
  }

  /**
   * Remove collections from a client's subscription list.
   *
   * When a client stops syncing certain collections, call this
   * to stop sending them broadcasts for those collections.
   *
   * @param id - The client ID
   * @param collections - Collection names to remove
   */
  removeCollections(id: string, collections: string[]): void {
    const client = this.clients.get(id);
    if (!client) return;

    for (const collection of collections) {
      if (client.collections.has(collection)) {
        client.collections.delete(collection);

        const collectionClients = this.clientsByCollection.get(collection);
        if (collectionClients) {
          collectionClients.delete(id);
          if (collectionClients.size === 0) {
            this.clientsByCollection.delete(collection);
          }
        }
      }
    }
  }

  /**
   * Get all connected clients.
   *
   * @returns Array of all client objects
   */
  getAll(): ConnectedClient[] {
    return Array.from(this.clients.values());
  }

  /**
   * Get all clients for a specific user.
   *
   * Useful for:
   * - Enforcing per-user connection limits
   * - Sending user-specific notifications
   * - Disconnecting all of a user's sessions
   *
   * @param userId - The user ID to look up
   * @returns Array of clients for that user (may be empty)
   */
  getByUser(userId: string): ConnectedClient[] {
    const clientIds = this.clientsByUser.get(userId);
    if (!clientIds) return [];
    return Array.from(clientIds)
      .map((id) => this.clients.get(id))
      .filter((c): c is ConnectedClient => c !== undefined);
  }

  /**
   * Get all clients subscribed to a collection.
   *
   * Used for broadcasting changes to interested clients.
   *
   * @param collection - The collection name
   * @returns Array of clients subscribed to that collection
   */
  getByCollection(collection: string): ConnectedClient[] {
    const clientIds = this.clientsByCollection.get(collection);
    if (!clientIds) return [];
    return Array.from(clientIds)
      .map((id) => this.clients.get(id))
      .filter((c): c is ConnectedClient => c !== undefined);
  }

  /**
   * Get all clients except one, optionally filtered by collection.
   *
   * Primary use case: broadcasting changes to other clients when
   * one client pushes changes.
   *
   * @param exceptId - Client ID to exclude from results
   * @param collection - Optional collection filter
   * @returns Array of other clients
   *
   * @example
   * ```typescript
   * // Broadcast to all other clients watching 'todos'
   * const others = manager.getOthers(senderClientId, 'todos');
   * for (const client of others) {
   *   client.socket.send(JSON.stringify(message));
   * }
   * ```
   */
  getOthers(exceptId: string, collection?: string): ConnectedClient[] {
    if (collection) {
      return this.getByCollection(collection).filter((c) => c.id !== exceptId);
    }
    return this.getAll().filter((c) => c.id !== exceptId);
  }

  /**
   * Get the total number of connected clients.
   */
  get count(): number {
    return this.clients.size;
  }

  /**
   * Check if a client with the given ID exists.
   *
   * @param id - The client ID to check
   * @returns true if the client exists
   */
  has(id: string): boolean {
    return this.clients.has(id);
  }

  /**
   * Remove all clients and clear all indexes.
   *
   * Called during server shutdown.
   */
  clear(): void {
    this.clients.clear();
    this.clientsByUser.clear();
    this.clientsByCollection.clear();
  }

  /**
   * Remove all clients that have been inactive longer than the threshold.
   *
   * Should be called periodically to clean up stale connections.
   *
   * @param maxInactiveMs - Maximum inactivity time in milliseconds
   * @returns Array of removed client IDs
   *
   * @example
   * ```typescript
   * // Remove clients inactive for more than 1 minute
   * setInterval(() => {
   *   const removed = manager.removeInactive(60000);
   *   if (removed.length > 0) {
   *     console.log(`Removed ${removed.length} inactive clients`);
   *   }
   * }, 30000);
   * ```
   */
  removeInactive(maxInactiveMs: number): string[] {
    const now = Date.now();
    const removed: string[] = [];

    for (const [id, client] of this.clients) {
      if (now - client.lastActiveAt > maxInactiveMs) {
        this.remove(id);
        removed.push(id);
      }
    }

    return removed;
  }
}

/**
 * Create a new client manager instance.
 *
 * @returns A new ClientManager instance
 *
 * @example
 * ```typescript
 * const manager = createClientManager();
 * ```
 *
 * @see {@link ClientManager}
 */
export function createClientManager(): ClientManager {
  return new ClientManager();
}
