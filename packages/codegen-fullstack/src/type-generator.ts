import type { FieldDef, GeneratedFile, SchemaDefinition } from './types.js';

export interface TypeGenerator {
  generate(schema: SchemaDefinition): GeneratedFile[];
  generateValidation(schema: SchemaDefinition): GeneratedFile[];
}

function fieldTypeToTs(field: FieldDef): string {
  const typeMap: Record<string, string> = {
    string: 'string',
    number: 'number',
    boolean: 'boolean',
    date: 'Date',
    object: 'Record<string, unknown>',
    array: 'unknown[]',
    enum: 'string',
  };

  let tsType = typeMap[field.type] ?? 'unknown';

  if (field.relation) {
    if (field.relation.type === 'one-to-many' || field.relation.type === 'many-to-many') {
      tsType = `${capitalize(field.relation.collection)}[]`;
    } else {
      tsType = capitalize(field.relation.collection);
    }
  }

  return tsType;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Creates a generator that produces TypeScript interfaces from a schema.
 */
export function createTypeGenerator(): TypeGenerator {
  function generate(schema: SchemaDefinition): GeneratedFile[] {
    const lines: string[] = [
      '// Auto-generated by @pocket/codegen-fullstack',
      '// Do not edit manually',
      '',
    ];

    for (const collection of schema.collections) {
      const interfaceName = capitalize(collection.name);
      lines.push(`export interface ${interfaceName} {`);

      const pk = collection.primaryKey ?? '_id';
      lines.push(`  ${pk}: string;`);

      for (const field of collection.fields) {
        const tsType = fieldTypeToTs(field);
        const optional = field.required ? '' : '?';
        lines.push(`  ${field.name}${optional}: ${tsType};`);
      }

      if (collection.timestamps) {
        lines.push('  createdAt?: Date;');
        lines.push('  updatedAt?: Date;');
      }

      if (collection.softDelete) {
        lines.push('  deletedAt?: Date;');
      }

      lines.push('}');
      lines.push('');
    }

    return [
      {
        path: 'types.ts',
        content: lines.join('\n'),
        overwrite: true,
      },
    ];
  }

  function generateValidation(schema: SchemaDefinition): GeneratedFile[] {
    const lines: string[] = [
      '// Auto-generated validation schemas by @pocket/codegen-fullstack',
      '// Do not edit manually',
      '',
    ];

    for (const collection of schema.collections) {
      const fnName = `validate${capitalize(collection.name)}`;
      lines.push(`export function ${fnName}(data: Record<string, unknown>): { valid: boolean; errors: string[] } {`);
      lines.push('  const errors: string[] = [];');

      for (const field of collection.fields) {
        if (field.required) {
          lines.push(`  if (data['${field.name}'] === undefined || data['${field.name}'] === null) {`);
          lines.push(`    errors.push('${field.name} is required');`);
          lines.push('  }');
        }

        if (field.type === 'string') {
          lines.push(`  if (data['${field.name}'] !== undefined && typeof data['${field.name}'] !== 'string') {`);
          lines.push(`    errors.push('${field.name} must be a string');`);
          lines.push('  }');
        } else if (field.type === 'number') {
          lines.push(`  if (data['${field.name}'] !== undefined && typeof data['${field.name}'] !== 'number') {`);
          lines.push(`    errors.push('${field.name} must be a number');`);
          lines.push('  }');
        } else if (field.type === 'boolean') {
          lines.push(`  if (data['${field.name}'] !== undefined && typeof data['${field.name}'] !== 'boolean') {`);
          lines.push(`    errors.push('${field.name} must be a boolean');`);
          lines.push('  }');
        }
      }

      lines.push('  return { valid: errors.length === 0, errors };');
      lines.push('}');
      lines.push('');
    }

    return [
      {
        path: 'validation.ts',
        content: lines.join('\n'),
        overwrite: true,
      },
    ];
  }

  return { generate, generateValidation };
}
