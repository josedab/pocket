/**
 * @pocket/cli - Generate Types Command
 *
 * Generates TypeScript types from collection schemas.
 *
 * @module @pocket/cli/commands
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { loadProjectConfig } from '../../config/loader.js';
import type { SchemaDef, SchemaFieldDef } from '../../config/types.js';

/**
 * Generate types options
 */
export interface GenerateTypesOptions {
  /** Output file path */
  output?: string;
  /** Working directory */
  cwd?: string;
}

/**
 * Convert schema field type to TypeScript type
 */
function fieldTypeToTS(field: SchemaFieldDef): string {
  switch (field.type) {
    case 'string':
      return 'string';
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'date':
      return 'Date';
    case 'object':
      return 'Record<string, unknown>';
    case 'array':
      return 'unknown[]';
    default:
      return 'unknown';
  }
}

/**
 * Generate TypeScript interface from schema
 */
function generateInterface(name: string, schema: SchemaDef): string {
  const lines: string[] = [];
  lines.push(`export interface ${name} extends Document {`);

  for (const [fieldName, fieldDef] of Object.entries(schema.properties)) {
    const tsType = fieldTypeToTS(fieldDef);
    const optional = fieldDef.required ? '' : '?';
    lines.push(`  ${fieldName}${optional}: ${tsType};`);
  }

  lines.push('}');
  return lines.join('\n');
}

/**
 * Generate TypeScript types from config
 *
 * @param options - Generate options
 */
export async function generateTypes(options: GenerateTypesOptions = {}): Promise<void> {
  const cwd = options.cwd ?? process.cwd();

  // Load config
  const config = await loadProjectConfig(cwd);
  if (!config) {
    console.error('Error: No pocket.config.ts found. Run "pocket init" first.');
    process.exit(1);
  }

  const outputPath = options.output ?? 'pocket.types.ts';
  const fullOutputPath = path.resolve(cwd, outputPath);

  console.log('\nGenerating TypeScript types...\n');

  const lines: string[] = [
    '/**',
    ' * Auto-generated Pocket types',
    ` * Generated: ${new Date().toISOString()}`,
    ' * ',
    ' * DO NOT EDIT - This file is auto-generated by @pocket/cli',
    ' */',
    '',
    "import type { Document } from '@pocket/core';",
    '',
  ];

  const collections = config.collections ?? {};
  let generated = 0;

  for (const [collectionName, collectionConfig] of Object.entries(collections)) {
    if (collectionConfig.schema) {
      // Convert collection name to PascalCase for interface name
      const interfaceName = collectionName
        .split(/[-_]/)
        .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
        .join('');

      lines.push(generateInterface(interfaceName, collectionConfig.schema));
      lines.push('');
      console.log(`  ✓ ${interfaceName} (${collectionName})`);
      generated++;
    } else {
      console.log(`  ⚠ ${collectionName} - no schema defined`);
    }
  }

  // Add collection types map
  lines.push('/**');
  lines.push(' * Map of collection names to document types');
  lines.push(' */');
  lines.push('export interface CollectionTypes {');
  for (const [collectionName, collectionConfig] of Object.entries(collections)) {
    if (collectionConfig.schema) {
      const interfaceName = collectionName
        .split(/[-_]/)
        .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
        .join('');
      lines.push(`  ${collectionName}: ${interfaceName};`);
    }
  }
  lines.push('}');
  lines.push('');

  // Write output file
  fs.writeFileSync(fullOutputPath, lines.join('\n'));

  console.log(`\n✓ Generated ${generated} type(s) to: ${path.relative(cwd, fullOutputPath)}\n`);
}
