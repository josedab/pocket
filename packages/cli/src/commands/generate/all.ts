/**
 * @pocket/cli - Generate All Command
 *
 * Runs the full code generation pipeline from a Pocket schema file:
 * TypeScript types, React hooks, Zod validators, CRUD operations.
 *
 * Usage:
 *   pocket generate all [--schema <path>] [--output <dir>] [--watch]
 *   pocket generate hooks [--schema <path>] [--output <dir>]
 *   pocket generate zod [--schema <path>] [--output <dir>]
 *   pocket generate crud [--schema <path>] [--output <dir>]
 *
 * @module @pocket/cli/commands
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

export interface GenerateAllOptions {
  schema?: string;
  output?: string;
  generators?: string[];
  watch?: boolean;
  cwd?: string;
}

/** Schema file format (JSON or .pocket DSL). */
interface SchemaFileResult {
  format: 'json' | 'dsl';
  content: string;
  path: string;
}

function findSchemaFile(cwd: string, explicit?: string): SchemaFileResult | null {
  const candidates = explicit
    ? [explicit]
    : ['pocket.schema.json', 'pocket.schema.ts', 'schema.pocket', 'pocket.config.json'];

  for (const candidate of candidates) {
    const fullPath = path.resolve(cwd, candidate);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      const format = candidate.endsWith('.pocket') ? 'dsl' : 'json';
      return { format, content, path: fullPath };
    }
  }
  return null;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

function toSingular(str: string): string {
  if (str.endsWith('ies')) return str.slice(0, -3) + 'y';
  if (str.endsWith('ses') || str.endsWith('xes')) return str.slice(0, -2);
  if (str.endsWith('s') && !str.endsWith('ss')) return str.slice(0, -1);
  return str;
}

interface FieldInfo {
  name: string;
  type: string;
  required: boolean;
  tsType: string;
  zodType: string;
}

interface CollectionInfo {
  name: string;
  typeName: string;
  fields: FieldInfo[];
}

function mapFieldType(type: string): { tsType: string; zodType: string } {
  switch (type) {
    case 'string':
      return { tsType: 'string', zodType: 'z.string()' };
    case 'number':
      return { tsType: 'number', zodType: 'z.number()' };
    case 'boolean':
      return { tsType: 'boolean', zodType: 'z.boolean()' };
    case 'date':
      return { tsType: 'Date', zodType: 'z.date()' };
    case 'array':
      return { tsType: 'unknown[]', zodType: 'z.array(z.unknown())' };
    case 'object':
      return { tsType: 'Record<string, unknown>', zodType: 'z.record(z.unknown())' };
    case 'reference':
      return { tsType: 'string', zodType: 'z.string()' };
    default:
      return { tsType: 'unknown', zodType: 'z.unknown()' };
  }
}

function parseSchema(schemaFile: SchemaFileResult): CollectionInfo[] {
  interface RawField {
    type?: string;
    required?: boolean;
  }
  interface RawCollection {
    name?: string;
    fields?: Record<string, RawField>;
  }
  interface RawSchema {
    collections?: RawCollection[];
  }

  const data = JSON.parse(schemaFile.content) as RawSchema;
  const collections: CollectionInfo[] = [];

  for (const coll of data.collections ?? []) {
    const name = coll.name ?? 'unknown';
    const typeName = toPascalCase(toSingular(name));
    const fields: FieldInfo[] = [];

    for (const [fieldName, fieldDef] of Object.entries(coll.fields ?? {})) {
      const { tsType, zodType } = mapFieldType(fieldDef.type ?? 'string');
      fields.push({
        name: fieldName,
        type: fieldDef.type ?? 'string',
        required: fieldDef.required ?? false,
        tsType,
        zodType,
      });
    }

    collections.push({ name, typeName, fields });
  }

  return collections;
}

function generateTypeFile(collections: CollectionInfo[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated Pocket types',
    ` * Generated: ${new Date().toISOString()}`,
    ' * DO NOT EDIT ‚Äî This file is auto-generated by pocket generate',
    ' */',
    '',
  ];

  for (const coll of collections) {
    lines.push(`export interface ${coll.typeName} {`);
    lines.push('  _id: string;');
    for (const field of coll.fields) {
      const opt = field.required ? '' : '?';
      lines.push(`  ${field.name}${opt}: ${field.tsType};`);
    }
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

function generateHooksFile(collections: CollectionInfo[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated React hooks for Pocket collections',
    ` * Generated: ${new Date().toISOString()}`,
    ' * DO NOT EDIT ‚Äî This file is auto-generated by pocket generate',
    ' */',
    '',
    "import { useLiveQuery, usePocket } from '@pocket/react';",
    "import type { Observable } from 'rxjs';",
    "import type { " + collections.map((c) => c.typeName).join(', ') + " } from './types';",
    '',
  ];

  for (const coll of collections) {
    const name = coll.typeName;
    const collName = coll.name;

    // useList hook
    lines.push(`export function use${name}List(filter?: Partial<${name}>) {`);
    lines.push(`  return useLiveQuery<${name}>('${collName}');`);
    lines.push('}');
    lines.push('');

    // useById hook
    lines.push(`export function use${name}ById(id: string) {`);
    lines.push(`  const { data } = useLiveQuery<${name}>('${collName}');`);
    lines.push(`  return data.find((item) => item._id === id) ?? null;`);
    lines.push('}');
    lines.push('');

    // useMutations hook
    lines.push(`export function use${name}Mutations() {`);
    lines.push('  const { db } = usePocket();');
    lines.push('  return {');
    lines.push(`    create: (data: Omit<${name}, '_id'>) => db.collection('${collName}').insert(data),`);
    lines.push(`    update: (id: string, data: Partial<${name}>) => db.collection('${collName}').update({ _id: id }, { $set: data }),`);
    lines.push(`    remove: (id: string) => db.collection('${collName}').remove({ _id: id }),`);
    lines.push('  };');
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

function generateZodFile(collections: CollectionInfo[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated Zod validators for Pocket collections',
    ` * Generated: ${new Date().toISOString()}`,
    ' * DO NOT EDIT ‚Äî This file is auto-generated by pocket generate',
    ' */',
    '',
    "import { z } from 'zod';",
    '',
  ];

  for (const coll of collections) {
    lines.push(`export const ${coll.typeName}Schema = z.object({`);
    lines.push('  _id: z.string(),');
    for (const field of coll.fields) {
      const zodExpr = field.required ? field.zodType : `${field.zodType}.optional()`;
      lines.push(`  ${field.name}: ${zodExpr},`);
    }
    lines.push('});');
    lines.push('');
    lines.push(`export const ${coll.typeName}CreateSchema = ${coll.typeName}Schema.omit({ _id: true });`);
    lines.push(`export const ${coll.typeName}UpdateSchema = ${coll.typeName}Schema.partial().required({ _id: true });`);
    lines.push(`export type ${coll.typeName}Input = z.infer<typeof ${coll.typeName}CreateSchema>;`);
    lines.push('');
  }

  return lines.join('\n');
}

function generateCrudFile(collections: CollectionInfo[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated CRUD operations for Pocket collections',
    ` * Generated: ${new Date().toISOString()}`,
    ' * DO NOT EDIT ‚Äî This file is auto-generated by pocket generate',
    ' */',
    '',
    "import type { Database } from '@pocket/core';",
    "import type { " + collections.map((c) => c.typeName).join(', ') + " } from './types';",
    '',
  ];

  for (const coll of collections) {
    const name = coll.typeName;
    const collName = coll.name;

    lines.push(`// --- ${name} CRUD ---`);
    lines.push('');
    lines.push(`export async function create${name}(db: Database, data: Omit<${name}, '_id'>): Promise<${name}> {`);
    lines.push(`  return db.collection('${collName}').insert(data) as Promise<${name}>;`);
    lines.push('}');
    lines.push('');
    lines.push(`export async function get${name}(db: Database, id: string): Promise<${name} | null> {`);
    lines.push(`  return db.collection('${collName}').findOne({ _id: id }) as Promise<${name} | null>;`);
    lines.push('}');
    lines.push('');
    lines.push(`export async function update${name}(db: Database, id: string, data: Partial<${name}>): Promise<void> {`);
    lines.push(`  await db.collection('${collName}').update({ _id: id }, { $set: data });`);
    lines.push('}');
    lines.push('');
    lines.push(`export async function delete${name}(db: Database, id: string): Promise<void> {`);
    lines.push(`  await db.collection('${collName}').remove({ _id: id });`);
    lines.push('}');
    lines.push('');
    lines.push(`export async function list${name}s(db: Database): Promise<${name}[]> {`);
    lines.push(`  return db.collection('${collName}').find({}).exec() as Promise<${name}[]>;`);
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}

function generateIndexFile(generators: string[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated Pocket barrel export',
    ` * Generated: ${new Date().toISOString()}`,
    ' * DO NOT EDIT ‚Äî This file is auto-generated by pocket generate',
    ' */',
    '',
  ];

  if (generators.includes('types')) {
    lines.push("export * from './types';");
  }
  if (generators.includes('hooks')) {
    lines.push("export * from './hooks';");
  }
  if (generators.includes('zod')) {
    lines.push("export * from './validators';");
  }
  if (generators.includes('crud')) {
    lines.push("export * from './crud';");
  }
  lines.push('');

  return lines.join('\n');
}

/**
 * Run the full code generation pipeline.
 */
export async function generateAll(options: GenerateAllOptions = {}): Promise<void> {
  const cwd = options.cwd ?? process.cwd();
  const outputDir = path.resolve(cwd, options.output ?? './src/generated');
  const generators = options.generators ?? ['types', 'hooks', 'zod', 'crud'];

  console.log('\nüîß Pocket Code Generator\n');

  // Find and load schema
  const schemaFile = findSchemaFile(cwd, options.schema);
  if (!schemaFile) {
    console.error('‚ùå No schema file found.');
    console.error('   Create pocket.schema.json or specify --schema <path>');
    console.error('');
    console.error('   Example pocket.schema.json:');
    console.error('   {');
    console.error('     "version": "1.0.0",');
    console.error('     "collections": [{');
    console.error('       "name": "todos",');
    console.error('       "fields": {');
    console.error('         "title": { "type": "string", "required": true },');
    console.error('         "completed": { "type": "boolean" }');
    console.error('       }');
    console.error('     }]');
    console.error('   }');
    process.exit(1);
  }

  console.log(`  üìÑ Schema: ${path.relative(cwd, schemaFile.path)}`);
  console.log(`  üìÅ Output: ${path.relative(cwd, outputDir)}`);
  console.log(`  üîß Generators: ${generators.join(', ')}`);
  console.log('');

  const collections = parseSchema(schemaFile);
  if (collections.length === 0) {
    console.error('‚ùå No collections found in schema file.');
    process.exit(1);
  }

  // Ensure output directory
  fs.mkdirSync(outputDir, { recursive: true });

  let filesWritten = 0;

  // Generate each requested output
  if (generators.includes('types')) {
    const content = generateTypeFile(collections);
    fs.writeFileSync(path.join(outputDir, 'types.ts'), content);
    console.log('  ‚úì types.ts');
    filesWritten++;
  }

  if (generators.includes('hooks')) {
    const content = generateHooksFile(collections);
    fs.writeFileSync(path.join(outputDir, 'hooks.ts'), content);
    console.log('  ‚úì hooks.ts');
    filesWritten++;
  }

  if (generators.includes('zod')) {
    const content = generateZodFile(collections);
    fs.writeFileSync(path.join(outputDir, 'validators.ts'), content);
    console.log('  ‚úì validators.ts');
    filesWritten++;
  }

  if (generators.includes('crud')) {
    const content = generateCrudFile(collections);
    fs.writeFileSync(path.join(outputDir, 'crud.ts'), content);
    console.log('  ‚úì crud.ts');
    filesWritten++;
  }

  // Always generate index
  const indexContent = generateIndexFile(generators);
  fs.writeFileSync(path.join(outputDir, 'index.ts'), indexContent);
  filesWritten++;

  console.log(`\n‚ú® Generated ${filesWritten} file(s) for ${collections.length} collection(s)\n`);

  // Watch mode
  if (options.watch) {
    console.log(`üëÄ Watching ${path.relative(cwd, schemaFile.path)} for changes...\n`);
    fs.watchFile(schemaFile.path, { interval: 1000 }, () => {
      console.log('üîÑ Schema changed, regenerating...');
      void generateAll({ ...options, watch: false });
    });
  }
}
