/**
 * @pocket/cli - Deploy Config Generator
 *
 * Generates platform-specific deployment configuration files
 * and entry points for edge platforms.
 *
 * @module @pocket/cli/commands/deploy
 *
 * @example Generate Cloudflare Workers config
 * ```typescript
 * import { generateDeployConfig } from '@pocket/cli';
 *
 * const result = generateDeployConfig({
 *   target: 'cloudflare',
 *   projectName: 'my-app',
 *   envVars: { DATABASE_URL: 'sqlite:local' },
 * });
 *
 * for (const file of result.files) {
 *   console.log(file.path, file.content);
 * }
 * ```
 */

/**
 * Supported deployment targets.
 */
export type DeployTarget = 'cloudflare' | 'deno' | 'vercel' | 'fly';

/**
 * Options for generating deployment configuration.
 */
export interface ConfigGeneratorOptions {
  /** Target deployment platform */
  target: DeployTarget;
  /** Project name used in generated configs */
  projectName?: string;
  /** Output directory for generated files */
  outputDir?: string;
  /** Environment variables to include */
  envVars?: Record<string, string>;
  /** Port for the server (used by Fly.io and Deno) */
  port?: number;
  /** Cloudflare-specific: enable Durable Objects */
  durableObjects?: boolean;
  /** Cloudflare-specific: KV namespace bindings */
  kvNamespaces?: string[];
}

/**
 * A generated deployment file.
 */
export interface GeneratedFile {
  /** File path relative to output directory */
  path: string;
  /** File content */
  content: string;
  /** Whether the file is an entry point */
  isEntryPoint?: boolean;
}

/**
 * Result of config generation.
 */
export interface ConfigGeneratorResult {
  /** Target platform */
  target: DeployTarget;
  /** Generated files */
  files: GeneratedFile[];
  /** Deployment instructions */
  instructions: string[];
  /** Required CLI tools */
  requiredTools: string[];
}

/**
 * Generate deployment configuration for the specified target platform.
 *
 * @param options - Configuration generator options
 * @returns Generated files and deployment instructions
 *
 * @example
 * ```typescript
 * const result = generateDeployConfig({
 *   target: 'fly',
 *   projectName: 'my-pocket-app',
 *   port: 8080,
 * });
 * ```
 */
export function generateDeployConfig(options: ConfigGeneratorOptions): ConfigGeneratorResult {
  const projectName = options.projectName ?? 'pocket-app';
  const outputDir = options.outputDir ?? '.';

  switch (options.target) {
    case 'cloudflare':
      return generateCloudflareConfig(projectName, outputDir, options);
    case 'deno':
      return generateDenoConfig(projectName, outputDir, options);
    case 'vercel':
      return generateVercelConfig(projectName, outputDir, options);
    case 'fly':
      return generateFlyConfig(projectName, outputDir, options);
    default:
      throw new Error(`Unsupported deploy target: ${String(options.target)}`);
  }
}

function formatEnvVars(envVars: Record<string, string> | undefined, format: 'toml' | 'json' | 'env'): string {
  if (!envVars || Object.keys(envVars).length === 0) return '';

  switch (format) {
    case 'toml':
      return Object.entries(envVars)
        .map(([key, value]) => `${key} = "${value}"`)
        .join('\n');
    case 'json':
      return JSON.stringify(envVars, null, 2);
    case 'env':
      return Object.entries(envVars)
        .map(([key, value]) => `${key}=${value}`)
        .join('\n');
  }
}

function generateCloudflareConfig(
  projectName: string,
  outputDir: string,
  options: ConfigGeneratorOptions
): ConfigGeneratorResult {
  const compatDate = new Date().toISOString().slice(0, 10);
  const kvNamespaces = options.kvNamespaces ?? ['POCKET_KV'];
  const durableObjects = options.durableObjects ?? true;

  const configLines = [
    `name = "${projectName}"`,
    `main = "src/worker.ts"`,
    `compatibility_date = "${compatDate}"`,
    '',
    '[vars]',
    `POCKET_DB = "${projectName}"`,
  ];

  if (options.envVars) {
    configLines.push(formatEnvVars(options.envVars, 'toml'));
  }

  configLines.push('');

  for (const ns of kvNamespaces) {
    configLines.push(
      '[[kv_namespaces]]',
      `binding = "${ns}"`,
      `id = "your-${ns.toLowerCase()}-namespace-id"`,
      ''
    );
  }

  if (durableObjects) {
    configLines.push(
      '[durable_objects]',
      'bindings = [',
      '  { name = "POCKET_DO", class_name = "PocketDurableObject" }',
      ']',
      ''
    );
  }

  const entryContent = [
    '/**',
    ' * Pocket sync server entry point for Cloudflare Workers.',
    ' *',
    ' * Generated by @pocket/cli',
    ' */',
    '',
    "import { createEdgeSyncServer } from '@pocket/storage-edge';",
    "import { createCloudflareKVStorage } from '@pocket/storage-edge/cloudflare';",
    '',
    'export default {',
    '  async fetch(request: Request, env: Record<string, unknown>): Promise<Response> {',
    '    const storage = createCloudflareKVStorage({ namespace: env.POCKET_KV });',
    '    const server = createEdgeSyncServer({ storage });',
    '    return server.handleRequest(request);',
    '  },',
    '};',
    '',
  ].join('\n');

  return {
    target: 'cloudflare',
    files: [
      { path: `${outputDir}/wrangler.toml`, content: configLines.join('\n') },
      { path: `${outputDir}/src/worker.ts`, content: entryContent, isEntryPoint: true },
    ],
    instructions: [
      'Install Wrangler CLI: npm install -g wrangler',
      'Authenticate: wrangler login',
      ...kvNamespaces.map(ns => `Create KV namespace: wrangler kv:namespace create "${ns}"`),
      'Update the KV namespace IDs in wrangler.toml',
      'Deploy: wrangler deploy',
    ],
    requiredTools: ['wrangler'],
  };
}

function generateDenoConfig(
  projectName: string,
  outputDir: string,
  options: ConfigGeneratorOptions
): ConfigGeneratorResult {
  const port = options.port ?? 8787;

  const config = {
    tasks: {
      start: 'deno run --allow-net --allow-read --allow-env src/server.ts',
      dev: 'deno run --watch --allow-net --allow-read --allow-env src/server.ts',
    },
    imports: {
      '@pocket/storage-edge': 'npm:@pocket/storage-edge',
    },
  };

  const entryContent = [
    '/**',
    ' * Pocket sync server entry point for Deno.',
    ' *',
    ' * Generated by @pocket/cli',
    ' */',
    '',
    "import { createEdgeSyncServer } from '@pocket/storage-edge';",
    "import { createDenoKVStorage } from '@pocket/storage-edge/deno';",
    '',
    'const storage = createDenoKVStorage({});',
    'const server = createEdgeSyncServer({ storage });',
    '',
    `Deno.serve({ port: ${port} }, (request: Request) => {`,
    '  return server.handleRequest(request);',
    '});',
    '',
    `console.log('Pocket sync server running on http://localhost:${port}');`,
    '',
  ].join('\n');

  const files: GeneratedFile[] = [
    { path: `${outputDir}/deno.json`, content: JSON.stringify(config, null, 2) + '\n' },
    { path: `${outputDir}/src/server.ts`, content: entryContent, isEntryPoint: true },
  ];

  if (options.envVars && Object.keys(options.envVars).length > 0) {
    files.push({
      path: `${outputDir}/.env`,
      content: formatEnvVars(options.envVars, 'env') + '\n',
    });
  }

  return {
    target: 'deno',
    files,
    instructions: [
      'Install Deno: https://deno.land/manual/getting_started/installation',
      'Run locally: deno task start',
      `Deploy to Deno Deploy: deployctl deploy --project=${projectName} src/server.ts`,
    ],
    requiredTools: ['deno', 'deployctl'],
  };
}

function generateVercelConfig(
  projectName: string,
  outputDir: string,
  options: ConfigGeneratorOptions
): ConfigGeneratorResult {
  const config = {
    name: projectName,
    functions: {
      'api/sync.ts': {
        runtime: 'edge',
      },
    },
    routes: [
      { src: '/api/sync(.*)', dest: '/api/sync.ts' },
    ],
  };

  const entryContent = [
    '/**',
    ' * Pocket sync server entry point for Vercel Edge Functions.',
    ' *',
    ' * Generated by @pocket/cli',
    ' */',
    '',
    "import { createEdgeSyncServer } from '@pocket/storage-edge';",
    "import { createVercelKVStorage } from '@pocket/storage-edge/vercel';",
    '',
    'const storage = createVercelKVStorage({',
    '  url: process.env.KV_REST_API_URL!,',
    '  token: process.env.KV_REST_API_TOKEN!,',
    '});',
    'const server = createEdgeSyncServer({ storage });',
    '',
    "export const config = { runtime: 'edge' };",
    '',
    'export default async function handler(request: Request): Promise<Response> {',
    '  return server.handleRequest(request);',
    '}',
    '',
  ].join('\n');

  return {
    target: 'vercel',
    files: [
      { path: `${outputDir}/vercel.json`, content: JSON.stringify(config, null, 2) + '\n' },
      { path: `${outputDir}/api/sync.ts`, content: entryContent, isEntryPoint: true },
    ],
    instructions: [
      'Install Vercel CLI: npm install -g vercel',
      'Link project: vercel link',
      'Add KV store: vercel env add KV_REST_API_URL && vercel env add KV_REST_API_TOKEN',
      ...(options.envVars
        ? Object.keys(options.envVars).map(key => `Add env var: vercel env add ${key}`)
        : []),
      'Deploy: vercel deploy',
    ],
    requiredTools: ['vercel'],
  };
}

function generateFlyConfig(
  projectName: string,
  outputDir: string,
  options: ConfigGeneratorOptions
): ConfigGeneratorResult {
  const port = options.port ?? 8080;

  const configLines = [
    `app = "${projectName}"`,
    `primary_region = "iad"`,
    '',
    '[build]',
    '  builder = "heroku/buildpacks:20"',
    '',
    '[http_service]',
    `  internal_port = ${port}`,
    '  force_https = true',
    '  auto_stop_machines = true',
    '  auto_start_machines = true',
    '',
    '[env]',
    `  PORT = "${port}"`,
    `  POCKET_DB = "${projectName}"`,
  ];

  if (options.envVars) {
    for (const [key, value] of Object.entries(options.envVars)) {
      configLines.push(`  ${key} = "${value}"`);
    }
  }

  configLines.push('');

  const entryContent = [
    '/**',
    ' * Pocket sync server entry point for Fly.io.',
    ' *',
    ' * Generated by @pocket/cli',
    ' */',
    '',
    "import { createServer } from 'node:http';",
    "import { createEdgeSyncServer } from '@pocket/storage-edge';",
    '',
    `const port = parseInt(process.env.PORT ?? '${port}', 10);`,
    'const server = createEdgeSyncServer({});',
    '',
    'const httpServer = createServer(async (req, res) => {',
    "  const url = new URL(req.url ?? '/', `http://${req.headers.host}`);",
    '  const request = new Request(url.toString(), {',
    '    method: req.method,',
    "    headers: req.headers as Record<string, string>,",
    '  });',
    '  const response = await server.handleRequest(request);',
    '  res.writeHead(response.status, Object.fromEntries(response.headers.entries()));',
    '  const body = await response.text();',
    '  res.end(body);',
    '});',
    '',
    'httpServer.listen(port, () => {',
    '  console.log(`Pocket sync server running on http://localhost:${port}`);',
    '});',
    '',
  ].join('\n');

  const dockerfileContent = [
    'FROM node:20-slim',
    'WORKDIR /app',
    'COPY package*.json ./',
    'RUN npm ci --production',
    'COPY . .',
    'RUN npm run build',
    `EXPOSE ${port}`,
    'CMD ["node", "dist/server.js"]',
    '',
  ].join('\n');

  return {
    target: 'fly',
    files: [
      { path: `${outputDir}/fly.toml`, content: configLines.join('\n') },
      { path: `${outputDir}/src/server.ts`, content: entryContent, isEntryPoint: true },
      { path: `${outputDir}/Dockerfile`, content: dockerfileContent },
    ],
    instructions: [
      'Install Fly CLI: curl -L https://fly.io/install.sh | sh',
      'Authenticate: fly auth login',
      `Launch app: fly launch --name ${projectName}`,
      'Deploy: fly deploy',
    ],
    requiredTools: ['flyctl'],
  };
}
